import { supabase } from '@/lib/supabase/client'

export class AgentService {
  private supabaseClient: any

  constructor(supabaseClient?: any) {
    this.supabaseClient = supabaseClient || supabase
  }

  async getAgentChatLinkForOrganization(organizationId: string) {
    const { data, error } = await this.supabaseClient
      .from('agents')
      .select('*')
      .eq('organization_id', organizationId)
      .eq('channel', 'client_chat')
      .maybeSingle()
    if (error) throw error
    return data
  }

  async createAgentAndChannelForOrganization(organizationId: string, name: string) {
    // Check if we should update organization name from business info
    await this.updateOrganizationNameFromBusinessInfo(organizationId)

    // Create agent with channel included - much simpler!
    const { data: agent, error: agentError } = await this.supabaseClient
      .from('agents')
      .insert([{ 
        organization_id: organizationId, 
        name,
        greeting: `Hello! I'm ${name}, how can I help you today?`,
        tone: 'professional',
        goals: ['Provide helpful customer service', 'Answer questions about our business'],
        system_prompt: `You are ${name}, the AI assistant for this business. Be helpful, professional, and focus on assisting customers.`,
        paused: false,
        channel: 'client_chat',
        channel_config: {}
      }])
      .select('*')
      .single()
    if (agentError) throw agentError

    return { agent, channel: agent } // Return agent as both agent and channel for backward compatibility
  }

  /**
   * Update organization name from business info if it hasn't been updated yet
   */
  private async updateOrganizationNameFromBusinessInfo(organizationId: string): Promise<void> {
    try {
      // Get current organization
      const { data: organization, error: orgError } = await this.supabaseClient
        .from('organizations')
        .select('name')
        .eq('id', organizationId)
        .single()

      if (orgError || !organization) {
        console.log('‚ùå Could not fetch organization for name update')
        return
      }

      // Check if organization name looks auto-generated (contains "Organization" or is generic)
      const isAutoGenerated = organization.name.includes('Organization') || 
                              organization.name.includes('\'s Organization') ||
                              organization.name.includes('Company') ||
                              organization.name.length < 3

      if (!isAutoGenerated) {
        console.log('‚úÖ Organization name already looks good:', organization.name)
        return // Organization name already looks proper
      }

      // Get business name from business info fields
      const { data: businessNameField, error: fieldError } = await this.supabaseClient
        .from('business_info_fields')
        .select('field_value')
        .eq('organization_id', organizationId)
        .eq('field_name', 'business_name')
        .eq('is_answered', true)
        .single()

      if (fieldError || !businessNameField?.field_value) {
        console.log('üìù No business name found in onboarding data')
        return // No business name available
      }

      const businessName = businessNameField.field_value.trim()
      if (businessName.length === 0) {
        console.log('üìù Business name is empty')
        return
      }

      // Update organization name
      const { error: updateError } = await this.supabaseClient
        .from('organizations')
        .update({
          name: businessName,
          updated_at: new Date().toISOString()
        })
        .eq('id', organizationId)

      if (updateError) {
        console.error('‚ùå Failed to update organization name:', updateError)
      } else {
        console.log('‚úÖ Updated organization name from business info:', businessName)
      }
    } catch (error) {
      console.error('‚ùå Error updating organization name from business info:', error)
      // Don't throw - this is a fallback enhancement, not critical
    }
  }

  getThreshold(): number {
    return 10 // This could be made configurable via environment variable or database
  }

  async maybeCreateAgentChatLinkIfThresholdMet(
    organization: { id: string, slug: string }
  ) {
    // Check if onboarding is completed by querying setup_completion directly
    let isOnboardingCompleted = false
    try {
      const { data: setupStatus, error } = await this.supabaseClient
        .from('setup_completion')
        .select('setup_status')
        .eq('organization_id', organization.id)
        .single()
      
      if (!error && setupStatus) {
        isOnboardingCompleted = setupStatus.setup_status === 'completed'
      }
    } catch (error) {
      console.warn('Failed to check onboarding status:', error)
    }
    
    let agentChatLink = await this.getAgentChatLinkForOrganization(organization.id)
    
    // Only create agent chat link if onboarding is completed and no agent chat link exists
    if (isOnboardingCompleted && !agentChatLink) {
      agentChatLink = await this.createAgentAndChannelForOrganization(
        organization.id,
        organization.slug
      )
    }
    return agentChatLink
  }
}

// Export singleton instance for backward compatibility
export const agentService = new AgentService()

// Export individual functions for backward compatibility
export const getAgentChatLinkForOrganization = (organizationId: string) => agentService.getAgentChatLinkForOrganization(organizationId)
export const createAgentAndChannelForOrganization = (organizationId: string, name: string) => agentService.createAgentAndChannelForOrganization(organizationId, name)
export const maybeCreateAgentChatLinkIfThresholdMet = (organization: { id: string, slug: string }) => agentService.maybeCreateAgentChatLinkIfThresholdMet(organization) 